{"meta":{"title":"dengyang","subtitle":"dy","description":"120224.com# dengyang Deep Learning","author":"Young Teng","url":"http://120224.com"},"pages":[{"title":"友情链接","date":"2018-12-27T14:27:17.177Z","updated":"2018-12-27T14:27:17.177Z","comments":true,"path":"index.html","permalink":"http://120224.com/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2018-12-27T14:29:38.588Z","updated":"2018-12-27T14:29:38.588Z","comments":false,"path":"/404.html","permalink":"http://120224.com//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-12-27T14:29:38.582Z","updated":"2018-12-27T14:29:38.582Z","comments":false,"path":"books/index.html","permalink":"http://120224.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-28T19:37:08.656Z","updated":"2018-12-28T19:37:08.656Z","comments":true,"path":"about/index.html","permalink":"http://120224.com/about/index.html","excerpt":"","text":"个人详细介绍:一个矛盾纠结体处女座的苛求 + 天秤座的纠结一个没事总想胡乱鼓捣鼓捣的家伙爱好: 偶尔看看书,写些东西,发呆想写本关于自己的书,以后会更新在这个网站下 QQ: 568757336GithubID: 54dengyangWeChat: youngteng0923E-mail: youngteng@163.com"},{"title":"分类","date":"2018-12-27T14:29:38.591Z","updated":"2018-12-27T14:29:38.591Z","comments":false,"path":"categories/index.html","permalink":"http://120224.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-12-27T14:29:38.586Z","updated":"2018-12-27T14:29:38.585Z","comments":true,"path":"links/index.html","permalink":"http://120224.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-12-27T14:29:38.579Z","updated":"2018-12-27T14:29:38.579Z","comments":false,"path":"repository/index.html","permalink":"http://120224.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-27T14:29:38.585Z","updated":"2018-12-27T14:29:38.584Z","comments":false,"path":"tags/index.html","permalink":"http://120224.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网站闲置了一年多之后的感想","slug":"the_thought_of_no_manage_web_one_half_year_later","date":"2018-12-26T23:35:59.000Z","updated":"2019-01-01T23:00:42.521Z","comments":true,"path":"2018/12/27/the_thought_of_no_manage_web_one_half_year_later/","link":"","permalink":"http://120224.com/2018/12/27/the_thought_of_no_manage_web_one_half_year_later/","excerpt":"","text":"其实我在2017年06/07月份就应经把120224.com这个域名注册了,同时也在同事彭川大神的影响下开始接触hexo+github.io这个静态博客系统.之后也是随意搞搞搞,没有什么大的动作.后来09月23日左右又开始跟着李沐大神学习Gluon深度学习课程,这些东西也就不了了之了.最近是看到别人的博客时,发现别人的博客挺漂亮的就想到了自己的.自己的一直没有经营,还是以前的老theme.因为之前修过了mac-pro,导致自己的博客文件没有备份保存下来,同时又想直接摒弃以前的主题,所以最近就直接又新建了一个新的主题.以后这个博客还是可以多来记录记录自己的技术学习过程和自己的生活点点滴滴的,也是极好的呢.同时自己也有喜欢记录的习惯,就是偶尔总是拖延症附体,所以也都是断断续续不系统的记录.有时候也总是想改掉这个坏毛病,所以这个博客也就成了自己改掉坏习惯的一个”见证人”吧.后面的路还很长,希望自己勿忘初心,砥砺前行,脚踏实地的,千万不要再次好高骛远了.加油! 邓先森 2018-12-27 08:20 石榴庄","categories":[{"name":"随笔","slug":"随笔","permalink":"http://120224.com/categories/随笔/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://120224.com/tags/感想/"}]},{"title":"<(￣︶￣)> 网站更新情况记录 <(￣︶￣)>","slug":"the_logs_of_web_update","date":"2017-12-28T18:12:01.000Z","updated":"2018-12-31T17:08:52.093Z","comments":true,"path":"2017/12/29/the_logs_of_web_update/","link":"","permalink":"http://120224.com/2017/12/29/the_logs_of_web_update/","excerpt":"","text":"2019-01-01:1.添加了收录百度的功能,确保网站后期能被检索到.2.增加了www域名解析,以前120224.com可以访问,而www.120224.com不能访问. 2018-12-29:1.添加置顶功能.2.增添了日志发表时间,以前版本只到日期.3.添加了吴恩达课程和AstonZhang的友链.4.更改”沐神”为”李沐”,描述”~ 亚马逊 &amp; MXNet &amp; Gluon发起者 ~”改为”~ 亚马逊首席（principal）科学家，美国卡内基梅隆大学计算机系博士。~”.5.更改”~ B站课程 (经典) ~”为”~ B站《动手学深度学习》课程 (经典) ~”. 2018-12-28:1.将网站与七牛云连结,避免日后写文章添加图片的繁琐. 2018-12-27:1.添加评论功能,用了韩国的”来必力”.经过测试移动端貌似没有问题,就是pc端可能存在问题,To-do. 2018-12-26:1.将Next主题更新为Pure主题,重新开始.","categories":[{"name":"网站更新","slug":"网站更新","permalink":"http://120224.com/categories/网站更新/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://120224.com/tags/hexo/"}]},{"title":"kaggle上的房价预测竞赛练习,个人最好成绩达到0.15538","slug":"test-of-kaggle-house-prices-predict","date":"2017-09-23T17:25:24.000Z","updated":"2018-12-30T17:34:37.163Z","comments":true,"path":"2017/09/24/test-of-kaggle-house-prices-predict/","link":"","permalink":"http://120224.com/2017/09/24/test-of-kaggle-house-prices-predict/","excerpt":"","text":"&lt;未完待续&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201# -*- coding: utf-8 -*-# @Time : 2018/12/29 3:14 PM# @Author : dengyang# @Email : youngteng@163.com# @File : housePredict.py# @Software: PyCharm# 1.获取和读取数据集# 导包import gluonbook as gbfrom mxnet import autograd,nd,gluon,initfrom mxnet.gluon import data as gdata,loss as gloss,nnimport numpy as npimport pandas as pd# 读取数据train_data = pd.read_csv('./train.csv')test_data = pd.read_csv('./test.csv')# 查看下train和test数据的shape,规格大小print(train_data.shape)print(test_data.shape)# 查看下训练样本前四个样本的前四个特征,后两个特征和标签'''iloc和loc的区别： iloc，完全基于位置的索引. iloc的用法完全和numpy中的数字索引一样，开闭区间的逻辑也和Python是相同的。 要注意的是，如果iloc方括号中直接给定一个数字或者一个slice的话，默认索引的是行。 其中数字的情况会返回一个Series iloc主要使用数字来索引数据，而不能使用字符型的标签来索引数据。 而loc则刚好相反，只能使用字符型标签来索引数据，不能使用数字来 索引数据，不过有特殊情况，当数据框dataframe的行标签或者列标 签为数字，loc就可以来其来索引。'''print(train_data.iloc[0:4,[0,1,2,3,-3,-2,-1]])# 将所有数据的训练和测试数据的79个特征按样本连结all_features = pd.concat((train_data.iloc[:,1:-1],test_data.iloc[:,1:]))# 2.预处理数据# 对连续数值的特征做标准化:假设特征在整个数据集上的均值μ,标准差σ.# 我们可以将特征中每个值先减去μ,再除以σ得到标准化后的每一个特征值,# 缺失值替换成该特征的均值.# 下面的含义是:all_features的类型如果不是object类型则将特征的索引(index)传递给numeric_featuresnumeric_features = all_features.dtypes[all_features.dtypes != 'object'].index'''apply:TO-DO'''all_features[numeric_features] = all_features[numeric_features].apply(lambda x: (x - x.mean()) / (x.std()))# 下面代码含义:将all_features中含有NA的值用all_features的均值进行填充.all_features = all_features.fillna(all_features.mean())# 将离散数值转换成指示特征.如:特征A里面有两个不同的离散值1和2,那么这一步转换# 将去掉A特征,并新加两个新特征A_1和A_2,其值为0或1.# dummy_na=True,将缺失值也当做合法的特征值并为其创建指示特征all_features = pd.get_dummies(all_features,dummy_na=True)print(all_features.shape)# 此时将特征从79维增加到331维# 通过values属性得到NumPy格式的数据,并转成NDArray方便后继训练n_train = train_data.shape[0]train_features = nd.array(all_features[:n_train].values)# 因为之前将train和test所有的数据都合并成了一个文件,# 现在通过all_features[:n_train]和all_features[n_train:]将他们分开test_features = nd.array(all_features[n_train:].values)train_labels = nd.array(train_data.SalePrice.values).reshape((-1,1))# 3.训练模型# 使用基本线性回归模型和平方损失函数训练模型loss = gloss.L2Loss()def get_net(): net = nn.Sequential() net.add(nn.Dense(1)) net.initialize() return net# 定义此次比赛中用来评价模型的对数均方根误差.def log_rmse(net,features,labels): # 将小于1的值设成1,使得取对数时数值更稳定 ''' Numpy中clip函数的使用.numpy.clip(a, a_min, a_max, out=None) 其中a是一个数组，后面两个参数分别表示最小和最大值，也就是说clip这个 函数将将数组中的元素限制在a_min, a_max之间，大于a_max的就使得它等 于 a_max，小于a_min,的就使得它等于a_min。 ''' clipped_preds = nd.clip(net(features),1,float('inf')) rmse = nd.sqrt(2 * loss(clipped_preds.log(),labels.log()).mean()) # asscalar():Convert an array of size 1 to its scalar equivalent. # 将大小为1的数组转换为其标量等效值 return rmse.asscalar()def train(net,train_features,train_labels,test_features,test_labels, num_epochs,learning_rate,weight_decay,batch_size): train_ls,test_ls = [],[] train_iter = gdata.DataLoader(gdata.ArrayDataset(train_features,train_labels),batch_size,shuffle=True) # 使用Adam优化算法 trainer = gluon.Trainer(net.collect_params(),'adam',&#123;'learning_rate':learning_rate,'wd':weight_decay&#125;) for epoch in range(num_epochs): for X,y in train_iter: with autograd.record(): l = loss(net(X),y) l.backward() trainer.step(batch_size) train_ls.append(log_rmse(net,train_features,train_labels)) if test_labels is not None: test_ls.append(log_rmse(net,test_features,test_labels)) return train_ls,test_ls# 4.K折交叉验证def get_k_fold_data(k,i,X,y): # 返回第i折交叉验证时所需要的训练和验证数据 # 断言函数,做下判断,如果是false就报错退出 assert k &gt; 1 # 均分一下数据 fold_size = X.shape[0] // k X_train,y_train = None,None for j in range(k): # slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。 idx = slice(j * fold_size,(j + 1) * fold_size) X_part,y_part = X[idx,:],y[idx] if j == 1: X_valid,y_valid = X_part,y_part elif X_train is None: X_train,y_train = X_part,y_part else: X_train = nd.concat(X_train,X_part,dim=0) y_train = nd.concat(y_train,y_part,dim=0) return X_train,y_train,X_valid,y_valid# K折交叉验证我们训练k次并返回训练和验证的平均误差def k_fold(k,X_train,y_train,num_epochs,learning_rate,weight_decay,batch_size): train_l_sum,valid_l_sum = 0,0 for i in range(k): data = get_k_fold_data(k,i,X_train,y_train) net = get_net() train_ls,valid_ls = train(net,*data,num_epochs,learning_rate,weight_decay,batch_size) train_l_sum += train_ls[-1] valid_l_sum += valid_ls[-1] if i == 0: ''' 我们先定义作图函数semilogy，其中y轴使用了对数尺度。 def semilogy(x_vals, y_vals, x_label, y_label, x2_vals=None, y2_vals=None, legend=None, figsize=(3.5, 2.5)): gb.set_figsize(figsize) gb.plt.xlabel(x_label) gb.plt.ylabel(y_label) gb.plt.semilogy(x_vals, y_vals) if x2_vals and y2_vals: gb.plt.semilogy(x2_vals, y2_vals, linestyle=':') gb.plt.legend(legend) ''' gb.semilogy(range(1,num_epochs + 1),train_ls,'epochs','rmse',range(1,num_epochs +1),valid_ls,['train','valid']) print('fold %d,train rmse: %f,valid rmse: %f' % (i,train_ls[-1],valid_ls[-1])) return train_l_sum / k,valid_l_sum / k# 5.模型选择# 我们使用一组未经调优的超参数并计算交叉验证误差。你可以改动这些超参数来尽可能减小平均测试误差。k,num_epochs,lr,weight_decay,batch_size = 10,165,5,0,60train_l,valid_l = k_fold(k,train_features,train_labels,num_epochs,lr, weight_decay,batch_size)print('%d-fold validation: avg train rmse: %f,avg valid rmse: %f' % (k,train_l,valid_l))'''有时候你会发现一组参数的训练误差可以达到很低，但是在K折交叉验证上的误差可能反而较高。这种现象很可能是由于过拟合造成的。因此，当训练误差降低时，我们要观察K折交叉验证上的误差是否也相应降低。'''# 6.预测并在kaggle提交结果def train_and_pred(train_features,test_features,train_labels,test_data, num_epochs,lr,weight_decay,batch_size): net = get_net() train_ls,_ = train(net,train_features,train_labels,None,None, num_epochs,lr,weight_decay,batch_size) gb.semilogy(range(1,num_epochs + 1),train_ls,'epochs','rmse') print('train rmse %f' % train_ls[-1]) preds = net(test_features).asnumpy() test_data['SalePrice'] = pd.Series(preds.reshape(1,-1)[0]) submission = pd.concat([test_data['Id'],test_data['SalePrice']],axis=1) submission.to_csv('submission.csv',index=False)train_and_pred(train_features,test_features,train_labels,test_data, num_epochs,lr,weight_decay,batch_size)'''上述代码执行完之后会生成一个“submission.csv”文件。这个文件是符合 Kaggle 比赛要求的提交格式的。这时，我们可以在 Kaggle 上把我们预测得出的结果进行提交，并且查看与测试数据集上真实房价（标签）的误差。具体来说有以下几个步骤：你需要登录 Kaggle 网站，访问房价预测比赛网页，并点击右侧“Submit Predictions”或“Late Submission”按钮。然后，点击页面下方“Upload Submission File”图标所在的虚线框选择需要提交的预测结果文件。最后，点击页面最下方的“Make Submission”按钮就可以查看结果了''' 参数[10,100,5,0,64]运行结果: fold 0,train rmse: 0.166232,valid rmse: 0.144298fold 1,train rmse: 0.166070,valid rmse: 0.144265fold 2,train rmse: 0.166147,valid rmse: 0.144306fold 3,train rmse: 0.166064,valid rmse: 0.144525fold 4,train rmse: 0.165943,valid rmse: 0.144174fold 5,train rmse: 0.166049,valid rmse: 0.144230fold 6,train rmse: 0.166298,valid rmse: 0.144140fold 7,train rmse: 0.166498,valid rmse: 0.144192fold 8,train rmse: 0.165994,valid rmse: 0.144347fold 9,train rmse: 0.165646,valid rmse: 0.14396310-fold validation: avg train rmse: 0.166094,avg valid rmse: 0.144244 参数[10,150,5,0,64]运行结果:fold 0,train rmse: 0.150604,valid rmse: 0.128320fold 1,train rmse: 0.150390,valid rmse: 0.128391fold 2,train rmse: 0.150571,valid rmse: 0.128409fold 3,train rmse: 0.150316,valid rmse: 0.128166fold 4,train rmse: 0.150575,valid rmse: 0.128311fold 5,train rmse: 0.150286,valid rmse: 0.128477fold 6,train rmse: 0.150312,valid rmse: 0.128338fold 7,train rmse: 0.150612,valid rmse: 0.128469fold 8,train rmse: 0.150454,valid rmse: 0.128422fold 9,train rmse: 0.150375,valid rmse: 0.12814510-fold validation: avg train rmse: 0.150450,avg valid rmse: 0.128345train rmse 0.145164 参数[10,165,5,0,50]运行结果:fold 0,train rmse: 0.139469,valid rmse: 0.120657fold 1,train rmse: 0.139487,valid rmse: 0.120587fold 2,train rmse: 0.139366,valid rmse: 0.120478fold 3,train rmse: 0.139568,valid rmse: 0.120741fold 4,train rmse: 0.139651,valid rmse: 0.120759fold 5,train rmse: 0.139555,valid rmse: 0.120640fold 6,train rmse: 0.139403,valid rmse: 0.120650fold 7,train rmse: 0.139626,valid rmse: 0.120719fold 8,train rmse: 0.139548,valid rmse: 0.120652fold 9,train rmse: 0.139596,valid rmse: 0.12069410-fold validation: avg train rmse: 0.139527,avg valid rmse: 0.120658train rmse 0.135256","categories":[{"name":"动手学深度学习","slug":"动手学深度学习","permalink":"http://120224.com/categories/动手学深度学习/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://120224.com/tags/DeepLearning/"},{"name":"MXNet","slug":"MXNet","permalink":"http://120224.com/tags/MXNet/"},{"name":"Gluon","slug":"Gluon","permalink":"http://120224.com/tags/Gluon/"}]},{"title":"只有MXNet能拯救你!","slug":"only-mxnet-can-save-you","date":"2017-09-23T02:55:13.000Z","updated":"2019-01-07T09:36:36.802Z","comments":true,"path":"2017/09/23/only-mxnet-can-save-you/","link":"","permalink":"http://120224.com/2017/09/23/only-mxnet-can-save-you/","excerpt":"","text":"发现”新大陆”最近有幸拜读了李沐(沐神)和Aston zhang的大作–基于MXNet和Gluon的深度学习教程&lt;动手学深度学习&gt;.此课程简直是良心之作,完全免费面向几乎零基础的deep learner.其实自己自2016年下半年就在自学机器学习/深度学习的内容,到目前来看,最适合我的就是这门课程,言简意赅,概念方面也是层层递进,一点不拖泥带水,而且是亚马逊研究院主任及团队成员亲自授课指导,我真的找不到像他们这么奉献的团队了. 其实自己水平并不高,愚钝得很,每每在论坛上提问,Aston zhang也是很及时热情的解答,令我有了学下去的动力.真的很是感激. 坎坷求学路,有大神带”真香”:我2016年年底学过唐宇迪的机器学习/深度学习课程,2017年夏天也看过莫烦的博客,了解过七月在线,亦咨询过小象学院,但觉得都不是很适合我.要么就是皮毛,简浅无味,上升不到高度;要么深邃烧脑,不知所云,全篇PPT都是数学公式,让人望而却步.感觉都是骗人的,圈钱,为了赚钱什么课程都能做出来卖.当时真正开源的又少,大家都在韬光养晦地学习进步;有人分享就少之又少了,大神就更没时间去做这些了,所以说沐神团队能这些真的很伟大的!后来我在找课程无果的情况下,就去了B站,期间学过好多课程:有的断断续续不全面,也有的都是”科普”性质的easy lesson.直到一次偶然的机会(2017-09-11),我遇到了Gluon/MXNet,看了他们的视频觉得遇到了知音,索性就关注了他们,后期在斗鱼知乎上也都有关注的.直到此时,我才决定暂时放弃tensorflow和keras转而拥向MXNet的怀抱. 学海无涯学习总是孤独的,不知自己熬过了多少个寂静/深邃夜晚,放弃了多少简单快乐,又付出了多少宝贵的时间……或许只有等你成功的时候别人才会理解你吧,但在那之前请你坚持,努力,坚持努力.夯实基础也是很必要的,包括数学,英语,NumPy,pandas,Matplotlib,SciPy等等.因为有了扎实的基础,对你后面学习理解意义重大. 最后结尾不求别人理解关注,只求自己心安,对得起自己足矣!So,only mxnet can save you.fighting! 邓先森 2017.09.23 望京 资源分享 《动手学深度学习》，面向中文读者、能运行、可讨论。资源网站: zh.diveintodeeplearning.org现在已经更新为:http://zh.d2l.ai 《动手学深度学习》Bilibili网址:https://space.bilibili.com/209599371 《动手学深度学习》Github项目地址:https://github.com/d2l-ai/d2l-zh 李沐:http://www.cs.cmu.edu/~muli/ Aston zhang:https://www.astonzhang.com","categories":[{"name":"随笔","slug":"随笔","permalink":"http://120224.com/categories/随笔/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://120224.com/tags/感想/"}]},{"title":"leetcode_020_Valid_Parentheses","slug":"leetcode-020-Valid-Parentheses","date":"2017-08-20T18:39:16.000Z","updated":"2019-01-11T19:12:24.409Z","comments":true,"path":"2017/08/21/leetcode-020-Valid-Parentheses/","link":"","permalink":"http://120224.com/2017/08/21/leetcode-020-Valid-Parentheses/","excerpt":"","text":"给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true 示例 2: 输入: “()[]{}”输出: true 示例 3: 输入: “(]”输出: false 示例 4: 输入: “([)]”输出: false 示例 5: 输入: “{[]}”输出: true 解决方案算法 1.初始化栈 S。2.一次处理表达式的每个括号。3.如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的子表达式。4.如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。5.如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。![http://120224.com/20-Valid-Parentheses-Recursive-Property.png] 12345678910111213141516171819202122232425262728class Solution &#123; private HashMap&lt;Character,Character&gt; mappings; public Solution()&#123; this.mappings = new HashMap&lt;Character,Character&gt;(); this.mappings.put(')','('); this.mappings.put('&#125;','&#123;'); this.mappings.put(']','['); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(int i = 0;i &lt; s.length();i++)&#123; char c = s.charAt(i); if(this.mappings.containsKey(c))&#123; char topElement = stack.empty() ? '#' : stack.pop(); if(topElement != this.mappings.get(c))&#123; return false; &#125; &#125;else&#123; stack.push(c); &#125; &#125; return stack.isEmpty(); &#125;&#125; 复杂度分析 时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行O(1)的推入和弹出操作。 空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_026_Remove_Duplicates_from_Sorted_Array","slug":"leetcode-026-Remove-Duplicates-from-Sorted-Array","date":"2017-08-20T02:40:11.000Z","updated":"2019-01-07T02:49:51.503Z","comments":true,"path":"2017/08/20/leetcode-026-Remove-Duplicates-from-Sorted-Array/","link":"","permalink":"http://120224.com/2017/08/20/leetcode-026-Remove-Duplicates-from-Sorted-Array/","excerpt":"","text":"给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 方法：双指针法算法 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i]=nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] ≠ nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_014_Longest_Common_Prefix","slug":"leetcode-014-Longest-Common-Prefix","date":"2017-08-19T01:24:51.000Z","updated":"2019-01-07T01:48:57.387Z","comments":true,"path":"2017/08/19/leetcode-014-Longest-Common-Prefix/","link":"","permalink":"http://120224.com/2017/08/19/leetcode-014-Longest-Common-Prefix/","excerpt":"","text":"编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 解题思路:暴力法: 取出strs中第一个元素的第i个值和第j个元素的第i个值进行比较,相同则添加到sb中12345678910111213141516171819202122class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs.length == 0) return \"\"; if(strs.length == 1) return strs[0]; StringBuilder sb = new StringBuilder(); if(strs.length &gt; 1)&#123; int len = strs[0].length(); for(int i = 0;i &lt; len;i++)&#123; char curr = strs[0].charAt(i); for(int j = 1;j &lt; strs.length;j++)&#123; if(strs[j].length() &lt;= i || strs[j].charAt(i) != curr)&#123; return sb.toString(); &#125; if(strs[j].charAt(i) == curr &amp;&amp; j == strs.length - 1)&#123; sb.append(curr); &#125; &#125; &#125; &#125; return sb.toString(); &#125;&#125; 之后做了小改动,显得更简洁一些,用了substring()方法,但思路类似:12345678910111213141516class Solution &#123; public static String longestCommonPrefix(String[] strs) &#123; int count = strs.length; String prefix = \"\"; if(count != 0)&#123; prefix = strs[0]; &#125; for(int i=1; i&lt;count; i++)&#123; //关键代码，不断的从后往前截取字符串，然后与之相比，直到startsWith()返回true while(!strs[i].startsWith(prefix))&#123; prefix = prefix.substring(0, prefix.length()-1); &#125; &#125; return prefix; &#125;&#125; 采用方法 分别用时 1 9ms 2 13ms","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_007_Reverse_Integer","slug":"leetcode-007-Reverse-Integer","date":"2017-08-18T11:32:36.000Z","updated":"2019-01-07T01:48:06.622Z","comments":true,"path":"2017/08/18/leetcode-007-Reverse-Integer/","link":"","permalink":"http://120224.com/2017/08/18/leetcode-007-Reverse-Integer/","excerpt":"","text":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321 示例 3: 输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解决方案方法：弹出和推入数字 &amp; 溢出前进行检查 思路 我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法 反转整数的方法可以与反转字符串进行类比。 我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 temp = rev⋅10 + pop 时会导致溢出。 幸运的是，事先检查这个语句是否会导致溢出很容易。 为了便于解释，我们假设 rev 是正数。 如果 temp=rev⋅10+pop 导致溢出，那么一定有 rev≥ 10/(INTMAX) 。 如果 rev&gt; INTMAX / 10 ，那么 temp=rev⋅10+pop 一定会溢出。 如果 rev== INTMAX / 10，那么只要 pop&gt;7，temp=rev⋅10+pop 就会溢出。当 rev 为负时可以应用类似的逻辑。 12345678910111213class Solution &#123; public int reverse(int x) &#123; int rev = 0; while(x != 0)&#123; int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125; 复杂度分析 时间复杂度：O(log(x))，x 中大约有 log10(x) 位数字。 空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_013_Roman_to_Integer ","slug":"leetcode-013-Roman-to-Integer","date":"2017-08-17T10:42:24.000Z","updated":"2019-01-01T11:10:48.017Z","comments":true,"path":"2017/08/17/leetcode-013-Roman-to-Integer/","link":"","permalink":"http://120224.com/2017/08/17/leetcode-013-Roman-to-Integer/","excerpt":"","text":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 字符 数值 I 1 C 100 V 5 D 500 X 10 M 1000 L 50 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路我的思路是这样的: 先要判断输入的String s是不是非法数据,如果为空或长度为0,则直接return -1; 接下来设置一个key-value类型的HashMap,将罗马数字和对应的数值put进HashMap中; 做for循环将输入的s的每个元素中罗马数字对应的数值进行相加,傻瓜式相加,现在不用考虑任何形式的组合形式; 利用s.contains(“IV”) || s.contains(“IX”), s.contains(“XL”) || s.contains(“XC”), s.contains(“CD” || s.contains(“CM”)做判断,因为只有这六种形式是特殊情况,如若s中含有第一种形式则总结果-2,含有第二种形式则总结果-20,含有第三种形式则总结果-200. 最后返回return 总结果result.12345678910111213141516171819202122232425262728293031class Solution &#123; public int romanToInt(String s) &#123; if (s == null || s.length() == 0) return -1; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int len = s.length(); int result = 0; for (int i = 0; i &lt; len; i++) &#123; result += map.get(s.charAt(i)); &#125; if(s.contains(\"IV\") || s.contains(\"IX\"))&#123; result -= 2; &#125; if(s.contains(\"XL\") || s.contains(\"XC\"))&#123; result -= 20; &#125; if(s.contains(\"CD\") || s.contains(\"CM\"))&#123; result -= 200; &#125; return result; &#125;&#125; 结果总结但是提交结果不是很好,耗时需要112ms,又尝试了一下全用if语句和switch语句的形式,发现效果都要好于这个情况.所以还需寻找最优的算法解决. 复杂度分析 todo","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_009_Palindrome_Number","slug":"leetcode-009-Palindrome-Number","date":"2017-08-16T05:03:25.000Z","updated":"2019-01-07T01:48:18.455Z","comments":true,"path":"2017/08/16/leetcode-009-Palindrome-Number/","link":"","permalink":"http://120224.com/2017/08/16/leetcode-009-Palindrome-Number/","excerpt":"","text":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1: 输入: 121输出: true示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 方法：反转一半数字 思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于int.MAX，我们将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。 让我们看看如何将这个想法转化为一个算法。 算法 首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。 现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。 现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？ 我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。 123456789101112131415class Solution &#123; public boolean isPalindrome(int x) &#123; // 1.根据题意大意可知,当x小于零时是非回文数 // 2.当x不等于零时且个位为0也是非回文数 if(x&lt;0 || (x % 10 == 0 &amp;&amp; x != 0))&#123; return false; &#125; int halfX = 0; while(x &gt; halfX)&#123; halfX = halfX * 10 + x % 10; x /= 10; &#125; return x == halfX || x == halfX / 10; &#125;&#125; 复杂度分析 时间复杂度：O(log10(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为O(log10(n))。 空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"leetcode_001_Two_Sum","slug":"leetcode-001-Two-Sum","date":"2017-08-15T02:13:48.000Z","updated":"2019-01-07T01:47:51.964Z","comments":true,"path":"2017/08/15/leetcode-001-Two-Sum/","link":"","permalink":"http://120224.com/2017/08/15/leetcode-001-Two-Sum/","excerpt":"","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路:方法一:暴力法暴力法很简单.遍历每个元素x,并查找是否存在一个值与target - x相等的目标元素.123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i = 0;i &lt; nums.length;i++)&#123; for(int j = i + 1;j &lt; nums.length;j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123;i,j&#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 复杂度分析: 时间复杂度:O(n2),对于每个元素,我们都试图通过遍历数组的其余部分来寻找它所对应的目标元素,这将耗费O(n)的时间.因此时间复杂度为O(n2) 空间复杂度:O(1) 方法二:两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i &lt; nums.length;i++)&#123; map.put(nums[i],i); &#125; for(int i = 0;i &lt; nums.length;i++)&#123; int temp = target - nums[i]; if(map.containsKey(temp) &amp;&amp; map.get(temp) != i)&#123; return new int[] &#123;i,map.get(temp)&#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 复杂度分析： 时间复杂度：O(n)， 我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 方法三：一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i &lt; nums.length;i++)&#123; int temp = target - nums[i]; if(map.containsKey(temp))&#123; return new int[] &#123;map.get(temp),i&#125;; &#125; map.put(nums[i],i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 复杂度分析： 时间复杂度：O(n)， 我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。 采用方法 分别用时 1 44ms 2 11ms 3 4ms","categories":[{"name":"算法","slug":"算法","permalink":"http://120224.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://120224.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://120224.com/tags/java/"},{"name":"力扣","slug":"力扣","permalink":"http://120224.com/tags/力扣/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-06-22T05:14:25.000Z","updated":"2018-12-28T18:18:27.445Z","comments":true,"path":"2017/06/22/hello-world/","link":"","permalink":"http://120224.com/2017/06/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"http://120224.com/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://120224.com/tags/hexo/"}]}]}